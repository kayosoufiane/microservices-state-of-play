= Microservices : un √©tat des lieux
Thomas SCHWENDER <https://github.com/ardemius[@ardemius]>
// Handling GitHub admonition blocks icons
ifndef::env-github[:icons: font]
ifdef::env-github[]
:status:
:outfilesuffix: .adoc
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]
:imagesdir: ./images
:source-highlighter: highlightjs
// Next 2 ones are to handle line breaks in some particular elements (list, footnotes, etc.)
:lb: pass:[<br> +]
:sb: pass:[<br>]
// check https://github.com/Ardemius/personal-wiki/wiki/AsciiDoctor-tips for tips on table of content in GitHub
:toc: macro
:toclevels: 2
// To turn off figure caption labels and numbers
:figure-caption!:

toc::[]

NOTE: Cet article se base sur le talk https://www.youtube.com/watch?v=2VH8rQSKdk0[Microservices: Infinity War! Spring vs MicroProfile] que j'ai donn√© √† *Devoxx France 2019* avec ma coll√®gue Darren Boutros.

== Microservices : un rien d'histoire et de contexte

On peut voir l‚Äô*architecture microservices* comme une √©volution l‚Äôarchitecture *SOA* (Service Oriented Architecture), elle-m√™me cr√©√©e pour pallier aux inconv√©nients des *applications monolithiques*.

image:microservices-etat-des-lieux_01.jpg[]

* Un des points int√©ressants √† remarquer dans la transition SOA vers l‚Äôarchitecture microservices, est la *suppression de l‚ÄôESB* (Enterprise Service Bus). +
La communication entre les services devait √™tre la principale fonction de ce composant, mais il embarquait fr√©quemment une *trop grande complexit√© m√©tier*. +
Pour corriger cela, il a √©t√© *remplac√© par les endpoints REST des microservices*. +
Pour illustrer ce changement, Martin Fowler palera de _"Smart endpoints and Dumb pipes"_

* On constate √©galement que l'on ne travaille plus avec un seul et unique runtime, mais avec *1 runtime par microservice*, ce qui participe √† garantir une de leurs principales caract√©ristiques :  l'*isolation*.

=== L'inspiration des microservices

En 2005, Alistair Cockburn pr√©sentait l‚Äô*architecture hexagonale* (ou mod√®le *‚ÄúPorts and Adapters‚Äù*) afin de permettre la conception d‚Äôapplications pouvant √™tre test√©es en *isolation de leurs runtimes et bases de donn√©es*.

Cela a √©t√© l‚Äôinspiration pour l‚Äôarchitecture microservices, dont Alistair donna ensuite la d√©finition suivante : _‚ÄúAn architectural style or an approach for building IT systems as a set of business capabilities that are autonomous, self contained, and loosely coupled‚Äù_

=== Architecture hexagonale

image::microservices-etat-des-lieux_02.jpg[]

IMPORTANT: Le principe fondateur de ce pattern est que [red]*le m√©tier ne doit d√©pendre de rien* : TOUTES les d√©pendances vont de *l‚Äôext√©rieur vers l‚Äôint√©rieur*.

Le but principal de cette architecture ne date pas d'hier, il est question de *s√©parer clairement le m√©tier de l'impl√©mentation technique* (notion d'*isolation*).

* Tout ce qui se trouve √† [red]*gauche de l'hexagone* repr√©sente [red]*les composants qui ont besoin de ce dernier*. +
On trouve c√¥t√© gauche des *interfaces expos√©es pour les composants ayant besoin d'invoquer le mod√®le*. On parle d'*API*, pour _Application Provider Interfaces_. +
-> Les composants souhaitant communiquer avec notre m√©tier le feront au travers d‚Äô*adaptateurs qui contacteront nos API*.

* Tout ce qui se trouve √† [red]*droite de l'hexagone* repr√©sente [red]*les composants dont ce dernier a besoin*. +
On trouve c√¥t√© droit des *interfaces expos√©es pour les composants que le mod√®le a besoin d‚Äôinvoquer*. On parle de *SPI*, pour _Service Provider Interfaces_. +
-> Les composants avec lesquels notre m√©tier souhaite communiquer seront contact√©s au travers des *SPI dont les impl√©mentations seront r√©solues √† l‚Äôex√©cution et fournies par des adaptateurs*.

=== Isolation

image::microservices-etat-des-lieux_03.jpg[align="center"]

Comme nous le verrons plus en d√©tail par la suite, la notion d'*isolation* est capitale pour les microservices, or *l'isolation am√®ne la redondance*, et cette derni√®re, on nous a appris √† la "combattre" depuis des dizaines d'ann√©es. +
Rappelez-vous le principe introduit dans https://www.amazon.fr/Pragmatic-Programmer-Journeyman-Master/dp/020161622X[_The Pragmatic Programmer_] : *Don't Repeat Yourself (DRY)*.

Prenons le cas de 2 classes partageant un m√™me comportement. +
Comme on nous l'a appris en programmation OO, on aura g√©n√©ralement tendance √† sortir ce comportement commun dans une classe de plus haut niveau, qui sera ensuite h√©rit√©e. +
Si on change le comportement de la classe m√®re, on impacte donc les 2 classes filles. +
Cet h√©ritage a donc augment√© le couplage entre nos classes.

[NOTE]
====
L'exemple pr√©c√©dent est... juste un exemple pour illustrer un probl√®me classique de couplage üòÖ +
On pourrait faire diff√©remment, en utilisant la composition ou d'autres patterns (ne me tappez pas... üòâ)
====

Dans le cas des microservices, nous voulons √©viter un maximum tout couplage, afin que ces derniers soient le plus *ind√©pendants* possible.
Donc, entre *DRY et couplage*, et [red]*isolation et redondance*, la 2nd approche est privil√©gi√©e.

.DDD et redondance
[NOTE]
====
La conception des microservices pl√©biscite l'approche *DDD* (*Domain Driven Design*). +
Cette approche, tout particuli√®rement le d√©coupage en *bounded context*, nous encourage tr√®s fortement √† limiter le couplage, quitte √† "se r√©p√©ter" par moment. +
Ce qui fait pencher encore un peu plus la balance vers "l'isolation et redondance".

Si vous voulez plus de d√©tails sur ce point, je vous conseille l'excellente conf√©rence https://www.youtube.com/watch?v=xZOO_CksS-E[Hexagonal at Scale, with DDD and microservices!] de Cyrille Martraire, lors du Voxxed Days Microservices Paris 2018.
====

=== Pourquoi les microservices ?

Du fait du d√©veloppement d‚ÄôInternet, tout le monde communique avec tout le monde, et est en concurrence avec tout le monde. +
L‚Äô√©mergence des microservices est la cons√©quence de l‚Äô*√©volution de nos applications* pour faire face √† ces nouveaux besoins :

* *Complexit√© croissante* +
Les applications ne se limitent plus au seul data center de la compagnie, mais communiquent avec les services externes d‚Äôautres providers sur tout le globe.
* *Besoin de livrer de plus en plus vite* +
Quand la concurrence est partout, il faut pouvoir faire √©voluer son produit rapidement, et donc √™tre capable de livrer des nouvelles fonctionnalit√©s au plus t√¥t, sans devoir attendre de release compl√®te.
* *Besoin de performance et de scalabilit√©* +
Il faut √™tre capable de s‚Äôadapter aux mont√©es en charge d‚Äôun march√© potentiellement mondial : tr√®s vite scaler sur de multiples serveurs, et lib√©rer les ressources tout aussi vite quand le pic de charge est pass√©.
* *Doivent √™tre toujours disponibles* +
Du fait de la comp√©tition de plus en plus sauvage, si votre application tombe, votre client part chez le concurrent... Votre application doit √™tre r√©siliente, et √™tre capable de g√©rer les pannes (on parlera pour cela de _"Design for Failures"_).

Pour adresser ces probl√©matiques, des soci√©t√©s comme Netflix, Amazon, eBay commenc√®rent √† *casser leurs monolithes* en services :

* de petite taille, chacun ne remplissant qu‚Äôune fonction
* pouvant √™tre *d√©ploy√©s ind√©pendamment* les uns des autres.

Ces services *distribu√©s*, *petits*, *simples* et *d√©coupl√©s* permirent aux applications de devenir *scalables*, *r√©silientes* et *flexibles*. +
-> Ils prirent progressivement le nom de *microservices*.

NOTE: La *d√©coupe des applications monolithiques* en microservices est donc le *Use Case d‚Äôorigine* des microservices.

== Principaux Use Cases

* "L‚Äôoriginel (le pass√©)" : Migration d‚Äôun monolithe vers une architecture microservices
* "L‚Äôactuel (le pr√©sent)" : D√©veloppement d‚Äôapplications *cloud-native*

La transition aux applications Cloud-native est bien expliqu√©e dans le https://www.amazon.fr/Spring-Microservices-Action-John-Carnell/dp/1617293989[Spring Microservices in Action] p5 :

____
You *start* building microservices because they give you a *high degree of flexibility and autonomy* with your development teams, but you and your team quickly find that the *small, independent nature of microservices makes them easily deployable to the cloud*.
____

=== Approche Cloud-native

.Cloud-Native approach : https://pivotal.io/fr/cloud-native
image::microservices-etat-des-lieux_04.jpg[]

Les microservices sont maintenant l‚Äô*architecture "par d√©faut"* pour b√¢tir des applications Cloud-native.

L'approche Cloud-native a les grandes caract√©ristiques suivantes :

* *Architecture microservices* : implique de *multiples √©quipes ind√©pendates*, travaillant √† l'am√©lioration du syst√®me.
* *Continuous Delivery* : Le CD repr√©sente un *process d'automatisation* permettant aux d√©veloppeurs de *d√©ployer rapidement* vers les environnements de prodution
* *DevOps* : La culture DevOps rapproche d√©veloppeurs et OPs, et les aide √† livrer une meilleure *valeur partag√©e* au client.
* *Containerized* : La notion de container est capitale, car ce sont ces derniers qui permettent aux applications de pouvoir √™tre d√©ploy√©es *n'importe o√π*. +
Ce qui importe n'est pas OU ces derni√®res sont d√©ploy√©es, mais COMMENT elles le sont.

Voici une d√©finition de l'approche Cloud-native que j'aime particuli√®rement :

[quote, 'https://medium.com/walmartlabs/cloud-native-application-architecture-a84ddf378f82[Cloud Native Application Architecture]']
____
Cloud native is an approach for building applications as micro-services and *running* them on a *containerised and dynamically orchestrated platforms* that *fully exploits the advantages of the Cloud computing model*.
____

On y parle d'exploiter les avantages qu'offre la conception dans le Cloud, afin de r√©pondre aux nombreuses contraintes inh√©rentes au d√©veloppement de microservices. +
En effet, le d√©veloppement de ces derniers est complexe, principalement car *ils sont nombreux*. +
On ne d√©veloppe jamais un mais *DES* microservices, dont il faut assurer la communication, le cycle de vie, le monitoring, etc etc.
Tout cela n√©cessite la mise en place d'un *environnement complexe*, on parlera de [red]*capability model*.

[NOTE]
====
Ce terme de *capability model* n'est pas si courant dans la litt√©rature sur les microservices, mais je le trouve tr√®s appropri√©. +
La gestion des logs, le monitoring centralis√©, la d√©couverte des services, etc. sont autant de "capabilities" qu'il est n√©cessaire de mettre en place pour assurer le bon fonctionnement de nos microservices.

A la base, je l'ai trouv√© dans l'excellent article https://hub.packtpub.com/capability-model-microservices/[A capability model for microservices] de Rajesh RV, l'auteur de https://www.packtpub.com/application-development/spring-microservices[Spring Microservices].
====

== Capability model

La conception de microservices ne se limite pas au simple code du service lui-m√™me, l'environnement, le *capability model* comme nomm√© pr√©c√©demment, est essentiel.

Faisons appara√Ætre ses "capabilities" progressivement :

video::microservices-etat-des-lieux_05.mp4[width=1000, start=0, end=10, options=autoplay]

=== Microservice "core"

Rappelons les caract√©ristiques des microservices :

* *"petits"* : comprendre par l√† qu'ils n'assurent la responsabilit√© que d'un point pr√©cis d'un domaine m√©tier.
* *faiblement coupl√©s* : donc ind√©pendants, et devant √™tre *d√©ploy√©s ind√©pendamment les uns des autres*. +
Pour aider √† cela, il est pr√©conis√© que chaque microservice dispose d'une *persistance d√©di√©e*.
* *distribu√©s*

=== API

Ce dernier va tr√®s rapidement devoir communiquer avec d'autres microservices, ce qui se fera au travers d'*API*.

=== Service Discovery

Afin que nos microservices puissent se trouver les uns les autres, ils s‚Äôenregistrent aupr√®s d‚Äôun *Service Discovery*.

=== Load Balancer

D√®s lor que vous avez *plusieurs instances d'un m√™me microservice*, vous avez besoin d'un *Load Balancer* pour distribuer le trafic et la charge.

=== API gateway

Il faut proposer un *point d'entr√©e unique* pour tous vos services. +
C'est le r√¥le L'*API gateway*, qui, de ce fait, est √©galement le lieu id√©al pour impl√©menter certains aspects transverses comme le *routage statique* et le *routage dynamique*. +
Par exemple, en fonction de certaines donn√©es de la requ√™te arrivante, on dirige une population de beta-testeurs sur une version sp√©cifique de certains services.

=== Communication entre microservices

Les microservices communiquent entre eux avec un *protocole l√©ger* et *ind√©pendant de leur technologie*.

la communication peut √™tre *synchrone* ou *asynchrone*.

==== Synchrone

Impl√©ment√©e au travers d'*appel REST en HTTP*.

Ce type de communication est g√©n√©ralement privil√©gi√© pour des *services externes*. +
Il est en effet id√©al pour des requ√™tes externes, car permettant de g√©rer facilement les *int√©ractions temps-r√©el* avec un client. +
N√©anmoins, son *inconv√©nient* est d'*augmenter le couplage* entre 2 microservices.

==== Asynchrone

Communication *Event Driven*, impl√©ment√©e via la mise en place d'un *bus d'√©v√®nements* (protocoles d'envoi de messages asynchrones AMQP, STOMP, MQTT et outils comme RabbitMQ, ActiveMQ), ou d'un *m√©canisme de Pub/Sub* (*Kafka* est le roi incontest√© de ce domaine...).

Ce type de communication est privil√©gi√© pour les √©changes relatif √† la "m√©canique interne" d'une fonctionnalit√© rendue par un ensemble de microservices (en d'autres termes, la "plomberie", ce qui n'est pas expos√© au client) +
Dans ces cas, le client n'attend g√©n√©ralement pas de r√©ponse imm√©diate, voire n'en attend tout simplement pas. +
Ces √©changes √©tant plus r√©pandus que les besoins d'int√©ractions temps r√©el, la communication asynchrone est la plus fr√©quemment rencontr√©e pour les microservices.

Ses avantages sont :

* *meilleur d√©couplage* des microservices
+
WARNING: Attention toutefois, on peut devenir d√©pendant (donc re-couplage) de la version du type de message. +
Exemple: JSON ne supporte pas nativement le versioning, contrairement √† Avro (pouss√© par Kafka)
* *meilleure r√©silience* : le message reste dans la queue m√™me si le consommateur est down.
* *meilleure scalabilit√©* : pas besoin d'attendre une r√©ponse du consommateur du message.
* *meilleure flexibilit√©* : √©metteur et consommateur ne se connaissent pas, on peut donc ajouter de nouveaux consommateurs sans impacter l‚Äô√©metteur.

C√¥t√© inconv√©nients :

* il faut se m√©fier de la gestion de l'*ordre des messages*.
* *debugging plus compliqu√©* : l'ex√©cution n'√©tant plus lin√©aire.

=== Configuration management

Vos microservices √©tant nombreux, vous n'allez pas g√©rer la configuration de chacun d'eux s√©paremment, il va donc falloir *centraliser leur configuration*.

=== Design for failure

Les microservices sont des syst√®mes distribu√©s, pour √©viter tout probl√®me de r√©seau, ou que la d√©faillance d‚Äôun service (ou instance de service) n‚Äôimpacte les autres, vous devez penser √† la r√©silience de l‚Äôapplication d√®s sa conception, ce qu‚Äôon appelle le *Design for failure*.

Voici les principaux patterns √† mettre en place :

* *circuit breaker* : pour √©viter que l‚Äôon continue d‚Äôappeler un microservice d√©faillant, permet le *fail fast*.
* *fallback* : propose un comportement alternatif en cas de d√©faillance d‚Äôun microservice (exemples : acc√®s √† une autre source de donn√©es, queueing de la requ√™te, etc.)
* *bulkhead* : on s√©pare les appels aux ressources distantes dans des thread pools diff√©rents (pour √©viter qu‚Äôun service d√©faillant ne vampirise les ressources)

=== Logging et tracing

Notre bon vieux monolithe a c√©d√© la place √† plusieurs dizaines ou centaines de microservices, en cons√©quence, la gestion des logs et du tracing est devenue bien plus compliqu√©e.

Chaque microservice a ses propres logs, et une transaction utilisateur peut impliquer plusieurs de ces derniers. +
Les patterns suivants permettent de ne pas se noyer dans cette masse de donn√©es :

* *log correlation* : via un *ID de corr√©lation*, permet de suivre les logs d‚Äôune transaction entre diff√©rents services
* *log aggregation* : regroupe toutes les logs en 1 m√™me persistance
* *tracing distribu√©* : permet de visualiser le flux / workflow d‚Äôune transaction utilisateur au travers des diff√©rents microservices

=== S√©curit√©

* *Authentification* : permet de savoir QUI veut se connecter √† vos services
* *Autorisation* : permet de savoir si l'utilisateur, pr√©c√©demment authentifi√©, a bien le droit d'entreprendre l'action qu'il souhaite (gestion de droits)
* *D√©l√©gation d‚Äôacc√®s* : pour √©viter que le service client n‚Äôait syst√©matiquement √† repr√©senter ses credentials pour chacun des services impliqu√©s dans la transaction

=== Patterns de build et de d√©ploiement

Nos microservices sont nombreux, on ne va pas pouvoir chacun les d√©ployer, ou les red√©marrer (gestion de panne), "√† la main", d'o√π la mise en place des patterns suivants :

* *CI/CD* : implique la mise en place d'un pipeline de build et de d√©ploiement automatis√©.
* *Infrastructure as code* : permet de consid√©rer le provisioning des nos services comme du code pouvant √™tre g√©r√© par un gestionnaire de sources.
* *Immutable infrastructure* : Une fois qu'un service est d√©ploy√©, l'infrastructure sur laquelle il tourne ne doit plus pouvoir √™tre modifi√©e par un humain. +
Cela renforce la stabilit√© du syst√®me, en garantissant qu'aucune modification ne peut se retrouver en PROD, dans le code d√©ploy√©, mais nulle part ailleurs...












